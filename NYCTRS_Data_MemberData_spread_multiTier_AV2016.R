

# Inputs:
#		1. Inputs_data/Data_MemberData_raw_AV2016.RData     (generated by NYCTRS_Data_readMemberData_AV2016.R)
         # - df_nactives,
         # - df_nactives_tier1,
         # - df_nactives_tier2,
         # - df_nactives_tier4,
         # - df_nactives_tier6,
         # - agecuts,
         # - yoscuts,
         # - df_nservRet,
         # - df_ndisbRet_acc,
         # - df_ndisbRet_ord,
         # - df_nsurvivors



# Outputs:
#   


#*********************************************************************************************************
#                      ## Global settings  ####
#*********************************************************************************************************

dir_data  <- "Inputs_data/"

#*********************************************************************************************************
#                      ##  Loading data  ####
#*********************************************************************************************************

load(paste0(dir_data, "Data_MemberData_raw_AV2016.RData"))




#*********************************************************************************************************
#                      ##  Exploring spreading the cells    ####
#*********************************************************************************************************

# Interpolation of actives
fillin.actives.spreadyos.splineage <- function(lactives) {
	# salary:
	#   first spread uniformly within age.cell-yos.cell group (same salary for all)
	#   then for every yos, estimate salary for each age using a spline - adjust endpoints first for plausibility
	#   finally, adjust resulting salary within each age.cell-yos.cell proportionately to hit total payroll values from grouped data
	#   then add ea to the data
	# nactives: spread uniformly within age.cell-yos.cell group (same nactives for all), then add ea to the data
	
	lactives
	
	adf <- lactives$actives.yos
	agecuts <- lactives$agecuts
	yoscuts <- lactives$yoscuts
	#eacuts <- lactives$eacuts
	minage <- min(agecuts$agelb)
	maxage <- max(agecuts$ageub)
	minyos <- min(yoscuts$yoslb)
	maxyos <- max(yoscuts$yosub)
	
	planname <- paste0(adf$planname[1])
	
	# adf %>% select(age, ea, salary) %>% spread(ea, salary)
	# adf %>% select(age, ea, nactives) %>% spread(ea, nactives)
	
	# create a master grouped data frame
	adf.g <- adf %>% select(-planname, -age, -yos, nactives.cell=nactives, salary.cell=salary) %>%
		mutate(pay.cell=nactives.cell * salary.cell) %>%
		mutate(ageidx = findInterval(age.cell, agecuts$agelb),
					 age.lb = agecuts$agelb[ageidx],
					 age.ub = agecuts$ageub[ageidx],
					 yosidx = findInterval(yos.cell, yoscuts$yoslb),
					 yos.lb = yoscuts$yoslb[yosidx],
					 yos.ub = yoscuts$yosub[yosidx]) %>%
		select(age.cell, yos.cell, age.lb, age.ub, yos.lb, yos.ub, nactives.cell, salary.cell, pay.cell)
  
  adf.g	

	# expand the grouped data frame to all allowable age-yos combinations ####
	xpnd <- function(df) {
		# expand to all age-yos combinations but only keep those where ea>=15 or, if there are no such records,
		# keep the recrods with max ea
		df2 <- expand.grid(age=df$age.lb:df$age.ub, yos=df$yos.lb:df$yos.ub) %>%
			mutate(ea=age - yos) %>%
			filter((ea >= 20) | (ea<20 & ea==max(ea))) %>%
			select(-ea)
		return(df2)
	}
	
	adf.x <- adf.g %>% rowwise() %>%
		do(cbind(., xpnd(.))) %>%
		ungroup %>%  # get rid of rowwise
		group_by(age.cell, yos.cell) %>%
		mutate(n.cell=n()) %>%
		select(age, yos, everything()) %>%
		arrange(age, yos)
	
	
	# work with the expanded data ####
	
	# we have to anchor the endpoints with reasonable values BEFORE computing the spline
	adjustends <- function(age, salary) {
		# the basic idea is that if an endpoint is NA, insert a plausible value
		
		# simple rule: if spline first or last value falls within +/ 50% of the nearest nonNA value, use spline estimate
		# otherwise use the capped value
		firstnonna <- salary[which.min(is.na(salary))]
		lastnonna <- rev(salary)[which.min(is.na(rev(salary)))]
		bound <- .5
		firstrange <- c(firstnonna * bound, firstnonna * (1 + bound))
		lastrange <- c(lastnonna * bound, lastnonna * (1 + bound))
		cap <- function(sal, range) {
			cappedval <- max(sal, range[1])
			cappedval <- min(cappedval, range[2])
			return(cappedval)
		}
		
		salary.est <- spline(age, salary, xout=age)$y # what does spline think naively?
		salary.adjusted <- salary
		
		if(is.na(salary[1])) salary.adjusted[1] <- cap(salary.est[1], firstrange)
		ilast <- length(salary)
		if(is.na(salary[ilast])) salary.adjusted[ilast] <- cap(salary.est[ilast], firstrange)
		
		return(salary.adjusted)
	}
	
	# test out adjustends
	# fs <- function(age, sal) return(spline(age, sal, xout=age)$y) # spline doesn't seem to work with dplyr if not in function
	# # various salaries to try out
	# salary <- seq(20, 50, length.out = 10)
	# salary <- c(20, NA, 30, NA, 40, NA, 50, NA, NA, 80)
	# salary <- c(20, NA, 30, NA, 40, NA, 50, NA, NA, 30)
	# salary <- c(NA, NA, 30, NA, 40, NA, 50, NA, NA, 30)
	# salary <- c(NA, NA, 30, NA, 40, NA, 50, NA, NA, NA)
	# salary <- c(NA, 10, 30, NA, 40, NA, 50, 80, NA, NA)
	# age <- 21:30
	# d <- data_frame(age, salary, saladj=adjustends(age, salary)) %>%
	#   mutate(sal.spline=fs(age, salary),
	#          saladj.spline=fs(age, saladj))
	# d
	# qplot(age, value, data=gather(d, variable, value, -age), colour=variable, geom=c("point", "line")) + scale_x_continuous(breaks=0:100) + geom_hline(y=0)
	
	
	spline.y2 <- function(age, salary, safesalary) {
		# safesalary is what we use if salary has no data
		if(all(is.na(salary))) {
			print("AllNA")
			salary <- safesalary
		}
		salary.adjusted <- adjustends(age, salary)
		
		sp.out <- spline(age, salary.adjusted, xout=age)
		salout <- sp.out$y
		return(salout)
	}
	
	adf.x3 <- adf.x %>% ungroup %>% # MUST be ungrouped or ifelse won't work if there is only one rec in a group
		mutate(nactives=nactives.cell / n.cell, # always spread nactives uniformly
					 salary.group=ifelse(age==age.cell & yos==yos.cell, salary.cell, NA),
					 salary.group=ifelse(salary.group==0, NA, salary.group),
					 salary.agecell=ifelse(age==age.cell, salary.cell, NA)) %>% # Yimeng's first step
		group_by(yos) %>%
		arrange(age) %>%
		mutate(salary.spline.adjep=spline.y2(age, salary.agecell, salary.cell)) %>% # Yimeng's 2nd step with endpoint adjustment
		group_by(age.cell, yos.cell) %>%
		mutate(planname=planname,
					 pay.unadj=sum(salary.spline.adjep * nactives),
					 adjust=pay.cell / pay.unadj,
					 salary.final=salary.spline.adjep * adjust,
					 pay.adj=sum(salary.final * nactives),
					 ea=age - yos
					 #ea.cell=eacuts$stub[findInterval(ea, eacuts$lb)]
		)
	
	return(adf.x3)
}

# data structure of the input list of fillin.actives.spreadyos.splineag
	# list name: lactives
	# $agecuts:
	#   - age.cell
	#   - agelb
	#   - ageub
	# $yoscuts:
	#   - yos.cell
	#   - yoslb
	#   - yosub
	# $actives.yos
	#   - age.cell
	#   - yos.cell
	#   - age
	#   - yos
	#   - planname
	#   - nactives
	#   - salary


# Interpolation of retirees
fillin.retirees <- function(list_data) {
	
	rdf <- select(list_data$data, planname, age, N, V) # keep only the vars we want
	agecuts <- list_data$agecuts
	
	planname <- paste0(rdf$planname[1], "_fillin")
	name_N <- list_data$varNames["name_N"]
	name_V <- list_data$varNames["name_V"]
	
	# add group ranges to the retirees data frame
	combo <- rdf %>%
		mutate(totben=N * V) %>%
		mutate(ageidx=findInterval(age, agecuts$agelb),
					 age.lb=agecuts$agelb[ageidx],
					 age.ub=agecuts$ageub[ageidx]) %>%
		arrange(age)
	
	# get avg benefits by age, via spline
	avgben <- splong(select(combo, age, V), "age", min(combo$age.lb):max(combo$age.ub))
	# force benefit to be non-negative DJB added 10/30/2015
	avgben <- avgben %>% mutate(V=ifelse(V<0, 0, V))
	
	guessdf <- data.frame(age=min(combo$age.lb):max(combo$age.ub)) %>%
		mutate(ageidx=findInterval(age, agecuts$agelb),
					 age.cell=combo$age[match(ageidx, combo$ageidx)],
					 N.cell=combo$N[match(ageidx, combo$ageidx)],
					 V.cell=combo$V[match(ageidx, combo$ageidx)]) %>%
		group_by(age.cell) %>%
		mutate(n.cell=n(),
					 N=N.cell / n.cell, # spread nretirees evenly
					 adjV=avgben$V[match(age, avgben$age)], # get the spline-based avg benefit
					 adjtotben=N * adjV)
	
	# refine the guess by adjusting ensure that we hit the right total benefits in each group
	guessdf2 <- guessdf %>% group_by(age.cell) %>%
		mutate(adjust=mean(N.cell * V.cell) / sum(adjtotben),
					 V=adjV*adjust,
					 totben=N * V)
	
	rdf.fillin <- guessdf2 %>% mutate(planname=planname) %>%
		select(planname, age.cell, age, N, V) %>%
		ungroup
	#plyr::rename(c("N" = list_data$varNames["name_N"])))
	
	names(rdf.fillin)[names(rdf.fillin) == "N"] <- name_N
	names(rdf.fillin)[names(rdf.fillin) == "V"] <- name_V
	
	return(rdf.fillin)
}

# data structure of the input list of fillin.actives.spreadyos.splineag
  # list name: ldata
  # $agecuts:
  #   - age.cell
  #   - agelb
  #   - ageub
  # $yoscuts:
  #   - yos.cell
  #   - yoslb
  #   - yosub
  # $data
  #   - age.cell
  #   - age
  #   - planname
  #   - N
  #   - V
  # $varNames
  #   - name_N
  #   - name_V  

planName <- "NYCTRS_AV2016"

get_agecuts <- function(df){
	df %>% 
		mutate(age.cell = (age_lb + age_ub)/ 2) %>% 
		select(age.cell, agelb = age_lb, ageub = age_ub) 
}


#*********************************************************************************************************
#                    1.  Initial actives   ####
#*********************************************************************************************************

# The output data frame includes active members of all tiers.
# May need to break it down later when modeling tiers separately. 


df_nactives
df_nactives_tier1


# Prepare data for the interpolation function


make_lactives <- function(df){
  lactives <- list(
  	agecuts = agecuts,
  	yoscuts = yoscuts,
  	actives.yos = 
  		df %>%
  		select(
  			planname = tier,
  			age.cell,
  			yos.cell,
  			nactives,
  			salary,
  		) %>%
  		mutate(age = age.cell, yos = yos.cell)
  )
}

fillin_actives <- function(df){

		fillin.actives.spreadyos.splineage(df) %>% 
		ungroup %>%
		select(planname, age, yos, ea,
					 #age.cell, yos.cell,
					 nactives, 
					 salary = salary.final) %>% 
		mutate_at(vars(nactives, salary), funs(na2zero))
	
}

lactives_allTiers <- make_lactives(df_nactives)
lactives_tier1 <- make_lactives(df_nactives_tier1)
lactives_tier2 <- make_lactives(df_nactives_tier2)
lactives_tier4 <- make_lactives(df_nactives_tier4)
lactives_tier6 <- make_lactives(df_nactives_tier6)

actives_fillin_allTiers <- fillin_actives(lactives_allTiers)
actives_fillin_tier1 <- fillin_actives(lactives_tier1)
actives_fillin_tier2 <- fillin_actives(lactives_tier2)
actives_fillin_tier4 <- fillin_actives(lactives_tier4)
actives_fillin_tier6 <- fillin_actives(lactives_tier6)


# Examine results
actives_fillin_spread <-
	actives_fillin_tier4 %>%
	select(age, yos, nactives) %>%
	spread(yos, nactives)

# salary_fillin_spread <-
# 	actives_fillin %>%
# 	select(age, yos, salary) %>%
# 	spread(yos, salary)
# 
# actives_fillin %>%
# 	summarise(avg.sal = sum(nactives * salary) / sum(nactives))


#*********************************************************************************************************
#                    2.  Initial Retirees   ####
#*********************************************************************************************************

ldata_servRet <- list(
	data = 
		df_nservRet %>%
		mutate(
			nservRet = nservRet_male + nservRet_female,
			benefit  = (nservRet_male * benefit_male + nservRet_female * benefit_female) / nservRet,
			age.cell = (age_lb + age_ub) / 2,
			planname = planName
		) %>%
		mutate_all(funs(ifelse(is.nan(.), 0, . ))) %>% 
		select(age.cell, N = nservRet, V = benefit, planname) %>% 
		mutate(age = age.cell) %>% 
		as.data.frame(), # otherwise, would lead to error in function splong
	
	agecuts = get_agecuts(df_nservRet) %>% as.data.frame(),
	
	varNames =
		tibble(name_N = "nservRet", name_V = "benefit_servRet")
)


init_servRet <- fillin.retirees(ldata_servRet) %>% mutate_all(funs(ifelse(is.nan(.), 0, . ))) 
# (init_servRet$nservRet *init_servRet$benefit_servRet) %>% sum
	


#*********************************************************************************************************
#                    3.  Initial survivors   ####
#*********************************************************************************************************

df_nsurvivors

ldata_survivors <- list(
	data =
		df_nsurvivors %>%
		mutate(
			nsurvivors = nsurvivors_male + nsurvivors_female,
			benefit  = (nsurvivors_male * benefit_male + nsurvivors_female * benefit_female) / nsurvivors,
			age.cell = (age_lb + age_ub) / 2,
			planname = planName
		) %>%
		mutate_all(funs(ifelse(is.nan(.), 0, . ))) %>% 
		select(age.cell, N = nsurvivors, V = benefit, planname) %>% 
		mutate(age = age.cell) %>% 
		as.data.frame(), # otherwise, would lead to error in function splong
	
	agecuts = get_agecuts(df_nsurvivors) %>% as.data.frame(),
	
	varNames =
		tibble(name_N = "nsurvivors", name_V = "benefit_survivors")
)
ldata_survivors


init_survivors <- fillin.retirees(ldata_survivors) %>% mutate_all(funs(ifelse(is.nan(.), 0, . ))) 
init_survivors



#*********************************************************************************************************
#                    4.  Initial disability retirees   ####
#*********************************************************************************************************

# adding accidental and ordinary disability retirees 

df_ndisbRet <- left_join(
	df_ndisbRet_acc %>% 
		mutate(
			ndisbRet_acc = ndisbRet_acc_male + ndisbRet_acc_female,
			benefit_acc  = (ndisbRet_acc_male * benefit_male + ndisbRet_acc_female * benefit_female) / ndisbRet_acc) %>% 
		select(age_lb, age_ub, ndisbRet_acc, benefit_acc),
		
	df_ndisbRet_ord %>% 
		mutate(
			ndisbRet_ord = ndisbRet_ord_male + ndisbRet_ord_female,
			benefit_ord  = (ndisbRet_ord_male * benefit_male + ndisbRet_ord_female * benefit_female) / ndisbRet_ord) %>% 
		select(age_lb, age_ub, ndisbRet_ord, benefit_ord)
)

df_ndisbRet %<>% 
	mutate(ndisbRet   = ndisbRet_acc + ndisbRet_ord,
				 benefit = (ndisbRet_acc * benefit_acc + ndisbRet_ord * benefit_ord) / ndisbRet
				 ) %>% 
	mutate_all(funs(ifelse(is.nan(.), 0, .))) %>% 
	select(age_lb, age_ub, ndisbRet, benefit)
df_ndisbRet



ldata_disbRet <- list(
	data =
		df_ndisbRet %>%
		mutate(
			age.cell = (age_lb + age_ub) / 2,
			planname = planName
		) %>%
		mutate_all(funs(ifelse(is.nan(.), 0, . ))) %>% 
		select(age.cell, N = ndisbRet, V = benefit, planname) %>% 
		mutate(age = age.cell) %>% 
		as.data.frame(), # otherwise, would lead to error in function splong
	
	agecuts = get_agecuts(df_ndisbRet) %>% as.data.frame(),
	
	varNames =
		tibble(name_N = "ndisbRet", name_V = "benefit_disbRet")
)
ldata_disbRet


init_disbRet <- fillin.retirees(ldata_disbRet) %>% mutate_all(funs(ifelse(is.nan(.), 0, . ))) 
init_disbRet



#*********************************************************************************************************
#                    5.  Gender ratio   ####
#*********************************************************************************************************
# This will be used for constructing decrement tables


init_genderRatios <- 
	bind_rows(
			
		   df_nactives_CAFR17 %>%
				summarise(num_male = sum(nactives_male),
									num_female = sum(nactives_female)) %>%
				mutate(pct_male = num_male / (num_male + num_female),
							 pct_female = 1 - pct_male,
							 planname = planName,
							 type = "actives"),
			
			
			df_nservRet %>% 
				summarise(num_male = sum(nservRet_male),
									num_female = sum(nservRet_female)) %>% 
				mutate(pct_male = num_male / (num_male + num_female), 
							 pct_female = 1 - pct_male,
							 planname = planName,
							 type = "servRet"),
			
			
			df_nsurvivors %>% # why share share of female so high for survivors?
				summarise(num_male = sum(nsurvivors_male),
									num_female = sum(nsurvivors_female)) %>% 
				mutate(pct_male = num_male / (num_male + num_female), 
							 pct_female = 1 - pct_male,
							 planname = planName,
							 type = "survivors"),
			
			
			bind_cols(
				select(df_ndisbRet_acc, ndisbRet_acc_male, ndisbRet_acc_female),
				select(df_ndisbRet_ord, ndisbRet_ord_male, ndisbRet_ord_female)
				) %>% 
				mutate(ndisbRet_male   = ndisbRet_acc_male, ndisbRet_ord_male,
							 ndisbRet_female = ndisbRet_acc_female, ndisbRet_ord_female) %>% 
				summarise(num_male = sum(ndisbRet_male),
									num_female = sum(ndisbRet_female)) %>% 
				mutate(pct_male = num_male / (num_male + num_female), 
							 pct_female = 1 - pct_male,
							 planname = planName,
							 type = "disbRet")
	) %>% 
	select(planname, type, everything())

init_genderRatios



#*********************************************************************************************************
#           6.1 Tier specific initial demographic data: actives   ####
#*********************************************************************************************************

# For actives:
  # 1. Merging tier 1 and tier 2 members into tier 4
  # 2. Splitting tier 4 members into tier 4 basic (t4a)  and tier 4 55program (t4b)




# Merging tier 1 and tier 2 members into tier 4
actives_fillin_tier4new <- 
  actives_fillin_tier4 %>% select(planname, age, yos, ea, nactives_tier4 = nactives, salary_tier4 = salary) %>% 
  left_join(actives_fillin_tier1 %>% select(age, yos, ea, nactives_tier1 = nactives, salary_tier1 = salary)) %>% 
	left_join(actives_fillin_tier2 %>% select(age, yos, ea, nactives_tier2 = nactives, salary_tier2 = salary)) %>% 
	mutate(nactive_tier4new = nactives_tier1 + nactives_tier2 + nactives_tier4,
				 salary_tier4new  = (nactives_tier1 * salary_tier1 + nactives_tier2 * salary_tier2 + nactives_tier4 * salary_tier4) / nactive_tier4new) %>% 
  select(planname, age, yos, ea, nactives = nactive_tier4new, salary = salary_tier4new) %>% 
	mutate_at(vars(nactives, salary), funs( replace(., is.nan(.), 0)))
	

# Splitting tier 4 members (tier 1 and 2 included) into tier 4 basic and tier 4 55program 

  t4_5527_minYOS <- 0
  t4_5527_maxYOS <- 9
  
  t4_basic_minYOS <- 10    # including 55/25 members 
  t4_basic_maxYOS <- Inf   # including 55/25 members
  
  nactives_55program <- 44918  # number of 55/25 and 55/27 members (TRS FOIL)
  
 
 actives_fillin_tier4new %<>% 
	mutate(
				 nactives_t4_5527   = ifelse(yos >= t4_5527_minYOS & yos <= t4_5527_maxYOS, nactives, 0),
				 salary_t4_5527     = ifelse(yos >= t4_5527_minYOS & yos <= t4_5527_maxYOS, salary,   0),
				 nactives_t4_basic  = ifelse(yos >= t4_basic_minYOS & yos <= t4_basic_maxYOS, nactives, 0),
				 salary_t4_basic    = ifelse(yos >= t4_basic_minYOS & yos <= t4_basic_maxYOS, salary,   0)
	)

 
  # Infer number of 55/25 members in nactives_t4_basic
  nactives_t4_5525 <- nactives_55program - sum(actives_fillin_tier4new$nactives_t4_5527)

  share_t4_5525inBasic = nactives_t4_5525 / sum(actives_fillin_tier4new$nactives_t4_basic)
  share_t4_5525inBasic 

  # About 23% of the members in nactives_t4_basic are in 55/25 program
  # For now, assume that
  #   - 1. 55/25 members accounts for the same share in all age-yos combos. 
  #   - 2. 55/25 members and basic tier 4 members have the same average salary at each age-yos combo


  
  actives_fillin_tier4new  %<>% 
	mutate(
		nactives_t4_5525   = nactives_t4_basic * share_t4_5525inBasic,
		salary_t4_5525     = salary_t4_basic ,
		nactives_t4_basic  = nactives_t4_basic * (1- share_t4_5525inBasic),
		salary_t4_basic    = salary_t4_basic
		
	)

  init_actives_t4a <- 
  	actives_fillin_tier4new  %>% 
  	mutate(tier = "t4a") %>% 
  	select(tier, age, yos, ea, nactives = nactives_t4_basic, salary = salary_t4_basic)
  
  init_actives_t4b <- 
  	actives_fillin_tier4new %>% 
  	mutate(nactives_t4b = nactives_t4_5525 + nactives_t4_5527,
  				 salary_t4b   = salary_t4_5525   + salary_t4_5527) %>% 
  	mutate(tier = "t4b") %>% 
  	select(tier, age, yos, ea, nactives = nactives_t4b, salary = salary_t4b)
  
  init_actives_t6 <- 
  	actives_fillin_tier6 %>% 
  	mutate(tier = "t6") %>% 
  	select(tier, age, yos, ea, nactives, salary)
  
  init_actives_allTiers <- 
  	actives_fillin_allTiers %>% 
  	mutate(tier = "allTiers") %>% 
  	select(tier, age, yos, ea, nactives, salary)
  
  
  
  init_actives_tiers <- 
  	bind_rows(
  		init_actives_t4a,
  		init_actives_t4b,
  		init_actives_t6,
  		init_actives_allTiers
  	)
  
  
  
  
#*********************************************************************************************************
#           6.2 Tier specific initial demographic data: retirees   ####
#*********************************************************************************************************
  
  # For retirees and beneficiaries
  # 1. Merging survivors into service retirees
  # 2. Assgin all regular and disability retirees to tier 4 basic (t4a), other tiers have 0 retirees. 
  
  init_servRet
  init_survivors
  init_disbRet
   
  init_servRet_new <- 
  init_servRet %>% 
  	full_join(init_survivors, by = "age") %>% 
  	mutate(nservRet_new        = nservRet + nsurvivors,
  				 benefit_servRet_new = (nservRet * benefit_servRet + nsurvivors * benefit_survivors)/nservRet_new) %>% 
  	mutate_all(funs(na2zero(.))) %>% 
  	select(age, nservRet = nservRet_new, benefit_servRet = benefit_servRet_new) %>% 
  	ungroup
  
  	
  init_servRet_t4a <- 
  	init_servRet_new %>% 
  	mutate(tier = "t4a") %>%   
  	select(tier, age, nservRet, benefit_servRet)
  	
  init_servRet_t4b <- 
  	init_servRet_new %>% 
  	mutate(tier = "t4b") %>% 
  	mutate(nservRet = 0) %>%  # keep benefit non-zero, which will be used in indivLab
  	select(tier, age, nservRet, benefit_servRet)
  
	init_servRet_t6 <- 
		init_servRet_new %>% 
		mutate(tier = "t6") %>% 
		mutate(nservRet = 0) %>% 
	  select(tier, age, nservRet, benefit_servRet)	
  
	init_servRet_allTiers <- 
		init_servRet_new %>% 
		mutate(tier = "allTiers") %>% 
		select(tier, age, nservRet, benefit_servRet)
	
	
	
	init_servRet_tiers <- bind_rows(
		init_servRet_t4a,
		init_servRet_t4b,
		init_servRet_t6,
		init_servRet_allTiers
	)



# disability retirees		
	  
	init_disbRet_t4a <- 
		init_disbRet %>% 
		mutate(tier = "t4a") %>% 
		select(tier, age, ndisbRet, benefit_disbRet)
	
	init_disbRet_t4b <- 
		init_disbRet %>% 
		mutate(tier = "t4b") %>% 
		mutate(ndisbRet = 0) %>% 
		select(tier, age, ndisbRet, benefit_disbRet)
	
	init_disbRet_t6 <- 
		init_disbRet %>% 
		mutate(tier = "t6") %>% 
		mutate(ndisbRet = 0) %>% 
		select(tier, age, ndisbRet, benefit_disbRet)	

	init_disbRet_allTiers <- 
		init_disbRet %>% 
		mutate(tier = "allTiers") %>% 
		select(tier, age, ndisbRet, benefit_disbRet)
		
	init_disbRet_tiers <- bind_rows(
		init_disbRet_t4a,
		init_disbRet_t4b,
		init_disbRet_t6,
		init_disbRet_allTiers
	)

		
# Placeholder for terminated workers
init_terms_tiers <- 
	init_disbRet_tiers %>% 
	filter(age < 62) %>% 
	mutate(nterms = 0) %>% 
	select(tier, age, nterms)
	
	
	 
#*********************************************************************************************************
#                    7.  save results   ####
#*********************************************************************************************************

init_actives_tiers
init_servRet_tiers
init_disbRet_tiers
init_terms_tiers
#init_survivors



save(
	init_actives_tiers,
	init_servRet_tiers,
	#init_survivors,
	init_disbRet_tiers,
	init_terms_tiers,
	file = paste0(dir_data, "Data_memberData_spread_wTiers_AV2016.RData")
)

save(init_genderRatios, 
		 file = paste0(dir_data, "Data_initGenderRatios_AV2016.RData")
)

#*********************************************************************************************************
#                    8.  examination   ####
#*********************************************************************************************************
# 
# df_TierShares
# 
# ntot <- init_actives$nactives %>% sum  # 118201
# nyos2 <- filter(init_actives, yos <=2)$nactives %>% sum
# nyos3 <- filter(init_actives, yos <=3)$nactives %>% sum
# nyos4 <- filter(init_actives, yos <=4)$nactives %>% sum
# 
# nyos2/ntot # 19.6%
# nyos3/ntot # 25.9%, 
# nyos4/ntot # 32.1%

# share of Tier 6 CAFR2017 ep163
# (FY or calendar year? year start or year end? should FY end. 
#  Would match better if it is FY start, but does not make sense for 2012)
 # 2015: 17.4%
 # 2016: 17.9%
 # 2017: 27.6%

# if use yos <= 3 as the cutting point, would assign too many people to Tier 6 (25.9% vs 17.9%)


